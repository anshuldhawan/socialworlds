<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>World1 â€¢ Spark + Three.js</title>
    <style> body { margin: 0; overflow: hidden; } html, body, canvas { width: 100%; height: 100%; } </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.174.0/three.module.js",
          "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.8/spark.module.js",
          "three/addons/": "https://unpkg.com/three@0.174.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="hud" style="position:fixed;left:8px;top:8px;color:#fff;background:rgba(0,0,0,0.5);padding:6px 8px;border-radius:4px;font:12px/1.4 monospace;z-index:10;pointer-events:none;white-space:pre"></div>
    <script type="module">
      import * as THREE from 'three';
      import { SplatMesh } from '@sparkjsdev/spark';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0.97, 0.02, -3.49);
      const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: 'high-performance' });
      let desiredPixelRatio = Math.min(window.devicePixelRatio, 1.0);
      const minPixelRatio = 0.5;
      const maxPixelRatio = Math.min(1.5, window.devicePixelRatio);
      renderer.setPixelRatio(desiredPixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      renderer.debug.checkShaderErrors = false;

      // Basic lighting isn't required for splats, but adding a neutral background helps
      renderer.setClearColor(0x000000, 1);

      // Controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 0.2;
      controls.maxDistance = 50;

      // Load local SPZ file
      const splatURL = './world1.spz';
      const world = new SplatMesh({ url: splatURL });
      // Orient and position so it's visible
      world.quaternion.set(1, 0, 0, 0);
      world.position.set(0, 0, -3);
      scene.add(world);
      world.updateMatrix();
      world.matrixAutoUpdate = false;
      controls.target.set(0, 0, -3);
      controls.update();

      // Camera bounds: keep camera and target within a sphere around the mesh center
      const boundsCenter = controls.target.clone();
      let boundsRadius = 2.0; // fallback radius if we can't infer
      // Try to infer radius if available on the object
      try {
        if (world.geometry && world.geometry.boundingSphere) {
          world.geometry.computeBoundingSphere();
          if (world.geometry.boundingSphere && world.geometry.boundingSphere.radius) {
            boundsRadius = world.geometry.boundingSphere.radius;
          }
        } else if (world.boundingSphere && world.boundingSphere.radius) {
          boundsRadius = world.boundingSphere.radius;
        }
      } catch (_) {}
      // Leave a small margin so we don't clip the boundary exactly
      const boundsMargin = 0.02;
      controls.maxDistance = Math.max(0.05, boundsRadius - boundsMargin);

      function clampToBounds() {
        const maxDist = Math.max(0.05, boundsRadius - boundsMargin);
        const offset = new THREE.Vector3().subVectors(camera.position, boundsCenter);
        const dist = offset.length();
        if (dist > maxDist) {
          offset.normalize().multiplyScalar(maxDist);
          camera.position.copy(boundsCenter).add(offset);
        }
        const tOffset = new THREE.Vector3().subVectors(controls.target, boundsCenter);
        const tDist = tOffset.length();
        const tMax = Math.max(0.0, boundsRadius - boundsMargin);
        if (tDist > tMax) {
          tOffset.normalize().multiplyScalar(tMax);
          controls.target.copy(boundsCenter).add(tOffset);
        }
      }
      controls.addEventListener('change', clampToBounds);
      // Expose a simple tuner in console if needed
      window.setBoundsRadius = (r) => { boundsRadius = Math.max(0.1, Number(r) || boundsRadius); controls.maxDistance = Math.max(0.05, boundsRadius - boundsMargin); clampToBounds(); };

      // Handle resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(desiredPixelRatio);
      }
      window.addEventListener('resize', onWindowResize);

      // Keyboard navigation (WASD to move, QE up/down, arrows also supported)
      const pressed = new Set();
      window.addEventListener('keydown', (e) => {
        pressed.add(e.key.toLowerCase());
      });
      window.addEventListener('keyup', (e) => {
        pressed.delete(e.key.toLowerCase());
      });

      const moveSpeedUnitsPerSecond = 1.5;
      const fastMultiplier = 3.0; // hold Shift for faster move
      let lastTimeMs = 0;
      let fpsEma = 0; // smoothed FPS
      const fpsAlpha = 0.1; // 0..1, higher = less smoothing
      let lastScaleAdjustMs = 0;

      function updateKeyboardNavigation(deltaSeconds) {
        let forward = 0;
        let right = 0;
        let upAxis = 0;

        if (pressed.has('w') || pressed.has('arrowup')) forward += 1;
        if (pressed.has('s') || pressed.has('arrowdown')) forward -= 1;
        if (pressed.has('d') || pressed.has('arrowright')) right += 1;
        if (pressed.has('a') || pressed.has('arrowleft')) right -= 1;
        if (pressed.has('e')) upAxis += 1;
        if (pressed.has('q')) upAxis -= 1;

        if (forward === 0 && right === 0 && upAxis === 0) return;

        const speed = moveSpeedUnitsPerSecond * (pressed.has('shift') ? fastMultiplier : 1.0);
        const distance = speed * deltaSeconds;

        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir); // forward vector
        const rightVec = dir.clone().cross(camera.up).normalize();
        const upVec = camera.up.clone().normalize();

        const move = new THREE.Vector3();
        move.addScaledVector(dir, forward);
        move.addScaledVector(rightVec, right);
        move.addScaledVector(upVec, upAxis);
        if (move.lengthSq() > 0) move.normalize().multiplyScalar(distance);

        camera.position.add(move);
        controls.target.add(move);
        clampToBounds();
      }

      // HUD
      const hud = document.getElementById('hud');
      function updateHUD() {
        const p = camera.position;
        const pr = renderer.getPixelRatio().toFixed(2);
        let heap = 'n/a';
        // Chrome-only: performance.memory
        if (performance && performance.memory && performance.memory.usedJSHeapSize) {
          heap = `${(performance.memory.usedJSHeapSize / (1024 * 1024)).toFixed(0)}MB`;
        }
        const mem = renderer.info.memory;
        hud.textContent = `fps: ${fpsEma.toFixed(1)}  pr: ${pr}  heap: ${heap}\ngeo: ${mem.geometries} tex: ${mem.textures}\npos: (${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)})`;
      }

      // Animate
      renderer.setAnimationLoop((time) => {
        const dt = lastTimeMs === 0 ? 0 : (time - lastTimeMs) / 1000;
        lastTimeMs = time;

        if (dt > 0) {
          const inst = 1 / dt;
          fpsEma = fpsEma === 0 ? inst : fpsEma + fpsAlpha * (inst - fpsEma);
        }

        // Dynamic resolution scaling (adjust every ~500ms)
        if (time - lastScaleAdjustMs > 500) {
          let changed = false;
          if (fpsEma && fpsEma < 30 && desiredPixelRatio > minPixelRatio) {
            desiredPixelRatio = Math.max(minPixelRatio, desiredPixelRatio - 0.05);
            changed = true;
          } else if (fpsEma && fpsEma > 58 && desiredPixelRatio < maxPixelRatio) {
            desiredPixelRatio = Math.min(maxPixelRatio, desiredPixelRatio + 0.05);
            changed = true;
          }
          if (changed) {
            renderer.setPixelRatio(desiredPixelRatio);
          }
          lastScaleAdjustMs = time;
        }

        updateKeyboardNavigation(dt);
        controls.update();
        clampToBounds();
        updateHUD();
        renderer.render(scene, camera);
      });
    </script>
  </body>
  </html>


